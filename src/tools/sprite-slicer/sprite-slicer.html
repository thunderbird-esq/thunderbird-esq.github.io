<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SPRITE SLICER - Thunderbird OS</title>
  <script>
    let opencvReady = false;
    function onOpenCvReady() {
      opencvReady = true;
      console.log('OpenCV.js is ready');
      document.getElementById('loadingIndicator').style.display = 'none';
    }
  </script>
  <script async src="/src/lib/opencv.js" onload="onOpenCvReady()"></script>
  <!-- Add JSZip and FileSaver.js for ZIP export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: #0ff;
      font-family: monospace;
      font-size: 14px;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: row;
    }
    .container {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .sidebar {
      width: 200px;
      background: #111;
      border-right: 2px solid #0ff;
      padding: 10px;
      overflow-y: auto;
      flex-shrink: 0;
      transition: width 0.3s;
    }
    .sidebar.hidden {
      width: 0;
      padding: 0;
      overflow: hidden;
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .workspace {
      flex: 1;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      padding: 10px;
      overflow: auto;
      gap: 20px;
    }
    .canvas-wrapper {
      position: relative;
      text-align: center;
      max-width: 50%;
      max-height: 80vh;
    }
    .canvas-label {
      position: absolute;
      top: -20px;
      left: 0;
      right: 0;
      color: #0ff;
      font-size: 12px;
    }
    .preview-section {
      width: 100px;
      background: #111;
      border-left: 2px solid #0ff;
      padding: 10px;
      overflow-y: auto;
      flex-shrink: 0;
      transition: width 0.3s;
    }
    .preview-section.hidden {
      width: 0;
      padding: 0;
      overflow: hidden;
    }
    .selection-window, .finishing-window {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      border: 2px solid #0ff;
      padding: 10px;
      z-index: 1000;
      display: none;
      flex-direction: column;
      align-items: center;
    }
    .selection-window canvas, .finishing-window canvas {
      border: 1px solid #0ff;
      max-width: 400px;
      max-height: 400px;
    }
    .selection-window button, .finishing-window button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
      margin: 5px;
    }
    .selection-window .corner-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #f00;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 0 3px #0ff;
      transition: transform 0.2s, background 0.2s;
    }
    .selection-window .corner-handle:hover {
      transform: scale(1.2);
      background: #ff5555;
    }
    .selection-window .corner-handle.dragging {
      transform: scale(1.5);
      background: #ffaaaa;
    }
    .selection-window .corner-handle.top-left {
      background: #f00;
    }
    .selection-window .corner-handle.top-right {
      background: #0f0;
    }
    .selection-window .corner-handle.bottom-left {
      background: #00f;
    }
    .selection-window .corner-handle.bottom-right {
      background: #ff0;
    }
    .finishing-window select, .finishing-window input {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px;
      margin: 5px;
    }
    .finishing-window .custom-size {
      display: none;
      margin: 10px 0;
    }
    h1, h2, h3 {
      margin: 0 0 10px;
      font-size: 20px;
      text-align: center;
    }
    h3 {
      font-size: 16px;
    }
    .mode-toggle {
      margin-bottom: 10px;
      text-align: center;
    }
    .mode-toggle label {
      margin: 0 5px;
    }
    .mode-toggle input[type="radio"] {
      margin: 0 2px;
    }
    details {
      margin: 10px 0;
    }
    summary {
      background: #222;
      padding: 5px;
      cursor: pointer;
      border: 1px solid #0ff;
    }
    .auto-controls, .manual-controls, .refine-controls {
      display: none;
      margin: 10px 0;
      padding: 10px;
      background: #222;
      border: 1px solid #0ff;
    }
    .control-group {
      margin: 5px 0;
    }
    .control-group label {
      display: block;
      margin: 5px 0;
    }
    .control-group input[type="range"] {
      width: 150px;
      margin: 0 5px;
    }
    .control-group input[type="number"] {
      width: 60px;
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px;
      margin: 0 5px;
    }
    .sidebar input[type="file"] {
      display: block;
      margin: 10px auto;
      color: #0ff;
      background: #111;
      border: 1px solid #0ff;
      padding: 5px;
    }
    .sidebar button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
      margin: 5px;
      width: 100%;
    }
    canvas {
      border: 1px solid #0ff;
      max-width: 100%;
      max-height: 100%;
    }
    #edgeCanvas {
      border: 1px solid #f00;
      max-width: 100%;
      max-height: 100%;
    }
    .status {
      text-align: center;
      padding: 5px;
      background: #222;
      border-bottom: 1px solid #0ff;
    }
    .preview-section h2 {
      margin: 0 0 10px;
      font-size: 16px;
      text-align: center;
    }
    .preview-section .frames {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    .preview-section img {
      border: 1px solid #0ff;
      max-width: 80px;
      max-height: 80px;
      cursor: pointer;
    }
    .preview-section img:hover {
      border-color: #f00;
    }
    .preview-section img.dragging {
      opacity: 0.5;
    }
    .action-section {
      text-align: center;
      padding: 10px;
      background: #222;
      border-top: 1px solid #0ff;
    }
    .action-section button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
      margin: 5px;
    }
    .toggle-buttons {
      position: absolute;
      top: 5px;
      left: 5px;
      display: flex;
      gap: 5px;
    }
    .toggle-buttons button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 2px 5px;
      cursor: pointer;
      font-size: 12px;
    }
    .loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      border: 2px solid #0ff;
      padding: 10px;
      z-index: 1000;
      color: #0ff;
      text-align: center;
    }
    @media (max-width: 1024px) {
      .container {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 2px solid #0ff;
      }
      .sidebar.hidden {
        height: 0;
        padding: 0;
      }
      .workspace {
        flex-direction: column;
        align-items: center;
      }
      .canvas-wrapper {
        max-width: 100%;
      }
      .preview-section {
        width: 100%;
        height: 120px;
        border-left: none;
        border-top: 2px solid #0ff;
      }
      .preview-section.hidden {
        height: 0;
        padding: 0;
      }
      .selection-window, .finishing-window {
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
      }
      .selection-window canvas, .finishing-window canvas {
        max-width: 300px;
        max-height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar" id="sidebar">
      <h1>SPRITE SLICER</h1>
      <div class="mode-toggle">
        <label><input type="radio" name="mode" value="auto" checked onclick="toggleMode()"> Auto Mode</label>
        <label><input type="radio" name="mode" value="refine" onclick="toggleMode()"> Refine Mode</label>
        <label><input type="radio" name="mode" value="manual" onclick="toggleMode()"> Manual Mode</label>
      </div>
      <input type="file" id="spriteSheetInput" accept="image/*">
      <details open>
        <summary>General Settings</summary>
        <div class="control-group">
          <label title="Enable corner adjustment for frames">
            <input type="checkbox" id="adjustCorners" checked onchange="drawCanvas()"> Adjust Corners
          </label>
        </div>
      </details>
      <details open>
        <summary>Grid Settings</summary>
        <div class="control-group">
          <label title="Number of rows for the grid">
            Rows: <input type="number" id="rowsInput" min="1" value="1" oninput="updateGridSettings()">
          </label>
          <label title="Number of columns for the grid">
            Columns: <input type="number" id="colsInput" min="1" value="1" oninput="updateGridSettings()">
          </label>
          <button onclick="sliceWithGrid()">Use Grid Slicing</button>
        </div>
      </details>
      <div class="auto-controls" id="autoControls">
        <details open>
          <summary>Edge Detection Settings</summary>
          <div class="control-group">
            <label title="Constrain edge detection to grid cells">
              <input type="checkbox" id="gridConstrainedEdge" onchange="autoSlice()"> Grid-Constrained Edge Detection
            </label>
            <label title="Adjust contrast to improve edge detection">
              Contrast:
              <input type="range" id="contrast" min="0.5" max="2" step="0.1" value="1" oninput="syncInput('contrast'); autoSlice()">
              <input type="number" id="contrastNum" min="0.5" max="2" step="0.1" value="1" oninput="syncSlider('contrast'); autoSlice()">
            </label>
            <label title="Apply Gaussian blur to reduce noise before edge detection">
              Blur Amount:
              <input type="range" id="blurAmount" min="1" max="15" step="2" value="3" oninput="syncInput('blurAmount'); autoSlice()">
              <input type="number" id="blurAmountNum" min="1" max="15" step="2" value="3" oninput="syncSlider('blurAmount'); autoSlice()">
            </label>
            <label title="Lower threshold for Canny edge detection (more edges if lower)">
              Edge Threshold 1:
              <input type="range" id="threshold1" min="0" max="255" value="50" oninput="syncInput('threshold1'); autoSlice()">
              <input type="number" id="threshold1Num" min="0" max="255" value="50" oninput="syncSlider('threshold1'); autoSlice()">
            </label>
            <label title="Upper threshold for Canny edge detection (fewer edges if higher)">
              Edge Threshold 2:
              <input type="range" id="threshold2" min="0" max="255" value="150" oninput="syncInput('threshold2'); autoSlice()">
              <input type="number" id="threshold2Num" min="0" max="255" value="150" oninput="syncSlider('threshold2'); autoSlice()">
            </label>
            <label title="Minimum area (in pixels) for a contour to be considered a frame">
              Min Contour Area:
              <input type="range" id="minContourArea" min="100" max="5000" value="100" oninput="syncInput('minContourArea'); autoSlice()">
              <input type="number" id="minContourAreaNum" min="100" max="5000" value="100" oninput="syncSlider('minContourArea'); autoSlice()">
            </label>
            <label title="Merge nearby contours into a single frame">
              <input type="checkbox" id="mergeContours" checked onchange="autoSlice()"> Merge Nearby Contours
            </label>
            <label title="Distance (in pixels) for merging nearby contours">
              Merge Distance:
              <input type="range" id="mergeDistance" min="0" max="50" value="10" oninput="syncInput('mergeDistance'); autoSlice()">
              <input type="number" id="mergeDistanceNum" min="0" max="50" value="10" oninput="syncSlider('mergeDistance'); autoSlice()">
            </label>
            <button onclick="resetSettings()">Reset to Defaults</button>
          </div>
        </details>
      </div>
      <div class="refine-controls" id="refineControls">
        <p>Click and drag the corners of the rectangles to adjust the detected frames.</p>
      </div>
      <div class="manual-controls" id="manualControls">
        <div class="control-group">
          <label title="Select the tool for manual selection">
            Tool:
            <select id="manualTool" onchange="updateManualTool()">
              <option value="rectangle">Rectangle</option>
              <option value="lasso">Lasso</option>
            </select>
          </label>
          <label title="Show grid overlay in manual mode">
            <input type="checkbox" id="showGrid" checked onchange="drawCanvas()"> Show Grid
          </label>
          <label title="Snap selections to the grid guides">
            <input type="checkbox" id="snapToGrid" checked> Snap to Grid
          </label>
          <label>Zoom: <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="1" oninput="updateZoom()"></label>
          <button onclick="undoLastSelection()">Undo Last Selection</button>
        </div>
      </div>
    </div>
    <div class="main-content">
      <div class="toggle-buttons">
        <button onclick="toggleSidebar()">Toggle Sidebar</button>
        <button onclick="togglePreview()">Toggle Preview</button>
      </div>
      <div class="status" id="status">Frames: 0</div>
      <div class="workspace">
        <div class="canvas-wrapper">
          <div class="canvas-label">Sprite Sheet</div>
          <canvas id="spriteCanvas"></canvas>
        </div>
        <div class="canvas-wrapper">
          <div class="canvas-label">Edge Detection Preview</div>
          <canvas id="edgeCanvas"></canvas>
        </div>
      </div>
      <div class="action-section">
        <button onclick="openFinishingWindow()">Open Finishing Window</button>
        <button onclick="exportAsZip()">Export as ZIP</button>
        <button onclick="exportToBigGifs()">Export to BIG GIFS LAB</button>
      </div>
    </div>
    <div class="preview-section" id="previewSectionContainer">
      <h2>Preview Frames</h2>
      <div class="frames" id="previewSection"></div>
    </div>
    <div class="selection-window" id="selectionWindow">
      <canvas id="selectionCanvas"></canvas>
      <div id="cornerHandles"></div>
      <button onclick="cropSelection()">Crop</button>
      <button onclick="closeSelectionWindow()">Close</button>
    </div>
    <div class="finishing-window" id="finishingWindow">
      <h2>Finishing Options</h2>
      <label>Frame Size Template:
        <select id="frameSizeTemplate" onchange="toggleCustomSize(); updateFinishingPreview()">
          <option value="gameboy_16x16">Game Boy (16x16)</option>
          <option value="nes_8x8">NES (8x8)</option>
          <option value="nes_16x16">NES (16x16)</option>
          <option value="snes_16x16">SNES (16x16)</option>
          <option value="snes_32x32">SNES (32x32)</option>
          <option value="snes_64x64">SNES (64x64)</option>
          <option value="genesis_32x32">Genesis (32x32)</option>
          <option value="custom">Custom</option>
        </select>
      </label>
      <div class="custom-size" id="customSizeInputs">
        <label>Width: <input type="number" id="customWidth" min="1" value="16" oninput="updateFinishingPreview()"></label>
        <label>Height: <input type="number" id="customHeight" min="1" value="16" oninput="updateFinishingPreview()"></label>
      </div>
      <label>Scale Factor:
        <input type="range" id="scaleFactor" min="0.5" max="4" step="0.1" value="1" oninput="updateScaleFactorValue(); updateFinishingPreview()">
        <span id="scaleFactorValue">1x</span>
      </label>
      <h3>Preview (First Frame)</h3>
      <canvas id="finishingPreviewCanvas"></canvas>
      <button onclick="applyFinishing()">Apply</button>
      <button onclick="closeFinishingWindow()">Cancel</button>
    </div>
    <div class="loading-indicator" id="loadingIndicator">
      <p>Loading OpenCV.js...</p>
      <p id="loadingError" style="display: none; color: #f00;">Failed to load OpenCV.js. Please check your network and try again.</p>
    </div>
  </div>

  <script>
    let mode = 'auto';
    let spriteImage = null;
    let frames = [];
    let manualSelections = [];
    let autoSelections = [];
    let isDragging = false;
    let startX, startY;
    let zoom = 1;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let lastPanX, lastPanY;
    let selectedCorner = null;
    let selectedRectIndex = null;
    let selectedArray = null;
    let manualTool = 'rectangle';
    let lassoPoints = [];
    let isLassoDrawing = false;
    let currentSelectionIndex = null;
    let lassoMode = 'add';
    let selectionCropRect = null;
    const canvas = document.getElementById('spriteCanvas');
    const ctx = canvas.getContext('2d');
    const edgeCanvas = document.getElementById('edgeCanvas');
    const edgeCtx = edgeCanvas.getContext('2d');
    const previewSection = document.getElementById('previewSection');
    const status = document.getElementById('status');
    const selectionWindow = document.getElementById('selectionWindow');
    const selectionCanvas = document.getElementById('selectionCanvas');
    const selectionCtx = selectionCanvas.getContext('2d');
    const cornerHandles = document.getElementById('cornerHandles');
    const finishingWindow = document.getElementById('finishingWindow');
    const finishingPreviewCanvas = document.getElementById('finishingPreviewCanvas');
    const finishingPreviewCtx = finishingPreviewCanvas.getContext('2d');

    const defaultSettings = {
      contrast: 1,
      blurAmount: 3,
      threshold1: 50,
      threshold2: 150,
      minContourArea: 100,
      mergeContours: true,
      mergeDistance: 10,
      rows: 1,
      cols: 1
    };

    setTimeout(() => {
      if (!opencvReady) {
        document.getElementById('loadingIndicator').innerHTML = '<p style="color: #f00;">Failed to load OpenCV.js. Please check your network and try again.</p>';
      }
    }, 10000);

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('hidden');
    }

    function togglePreview() {
      const preview = document.getElementById('previewSectionContainer');
      preview.classList.toggle('hidden');
    }

    function toggleMode() {
      mode = document.querySelector('input[name="mode"]:checked').value;
      document.getElementById('autoControls').style.display = mode === 'auto' ? 'block' : 'none';
      document.getElementById('refineControls').style.display = mode === 'refine' ? 'block' : 'none';
      document.getElementById('manualControls').style.display = mode === 'manual' ? 'block' : 'none';
      manualSelections = [];
      if (mode !== 'auto') frames = [];
      zoom = 1;
      panX = 0;
      panY = 0;
      document.getElementById('zoomSlider').value = 1;
      updatePreview();
      if (spriteImage) {
        if (mode === 'auto') autoSlice();
        drawCanvas();
      }
    }

    document.getElementById('spriteSheetInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        spriteImage = new Image();
        spriteImage.src = URL.createObjectURL(file);
        spriteImage.onload = () => {
          canvas.width = spriteImage.width;
          canvas.height = spriteImage.height;
          edgeCanvas.width = spriteImage.width;
          edgeCanvas.height = spriteImage.height;
          zoom = 1;
          panX = 0;
          panY = 0;
          const suggestedRows = Math.max(1, Math.round(spriteImage.height / 32));
          const suggestedCols = Math.max(1, Math.round(spriteImage.width / 32));
          document.getElementById('rowsInput').value = suggestedRows;
          document.getElementById('colsInput').value = suggestedCols;
          defaultSettings.rows = suggestedRows;
          defaultSettings.cols = suggestedCols;
          adjustEdgeDetectionSettings();
          drawCanvas();
          if (mode === 'auto' && opencvReady) autoSlice();
        };
      }
    });

    function adjustEdgeDetectionSettings() {
      if (!spriteImage) return;
      const imageArea = spriteImage.width * spriteImage.height;
      const suggestedMinContourArea = Math.max(100, Math.round(imageArea * 0.001));
      document.getElementById('minContourArea').value = suggestedMinContourArea;
      document.getElementById('minContourAreaNum').value = suggestedMinContourArea;
      defaultSettings.minContourArea = suggestedMinContourArea;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = spriteImage.width;
      tempCanvas.height = spriteImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(spriteImage, 0, 0);
      const src = cv.imread(tempCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const mean = cv.mean(gray);
      const suggestedThreshold1 = Math.max(30, Math.min(100, Math.round(mean[0] * 0.5)));
      const suggestedThreshold2 = Math.max(100, Math.min(200, Math.round(mean[0] * 1.5)));
      document.getElementById('threshold1').value = suggestedThreshold1;
      document.getElementById('threshold1Num').value = suggestedThreshold1;
      document.getElementById('threshold2').value = suggestedThreshold2;
      document.getElementById('threshold2Num').value = suggestedThreshold2;
      defaultSettings.threshold1 = suggestedThreshold1;
      defaultSettings.threshold2 = suggestedThreshold2;
      src.delete();
      gray.delete();
    }

    function syncInput(id) {
      document.getElementById(`${id}Num`).value = document.getElementById(id).value;
    }

    function syncSlider(id) {
      document.getElementById(id).value = document.getElementById(`${id}Num`).value;
    }

    function resetSettings() {
      document.getElementById('contrast').value = defaultSettings.contrast;
      document.getElementById('contrastNum').value = defaultSettings.contrast;
      document.getElementById('blurAmount').value = defaultSettings.blurAmount;
      document.getElementById('blurAmountNum').value = defaultSettings.blurAmount;
      document.getElementById('threshold1').value = defaultSettings.threshold1;
      document.getElementById('threshold1Num').value = defaultSettings.threshold1;
      document.getElementById('threshold2').value = defaultSettings.threshold2;
      document.getElementById('threshold2Num').value = defaultSettings.threshold2;
      document.getElementById('minContourArea').value = defaultSettings.minContourArea;
      document.getElementById('minContourAreaNum').value = defaultSettings.minContourArea;
      document.getElementById('mergeContours').checked = defaultSettings.mergeContours;
      document.getElementById('mergeDistance').value = defaultSettings.mergeDistance;
      document.getElementById('mergeDistanceNum').value = defaultSettings.mergeDistance;
      document.getElementById('rowsInput').value = defaultSettings.rows;
      document.getElementById('colsInput').value = defaultSettings.cols;
      if (spriteImage && mode === 'auto') autoSlice();
    }

    function updateGridSettings() {
      if (spriteImage && mode === 'auto') autoSlice();
      drawCanvas();
    }

    function autoSlice() {
      if (!spriteImage || !opencvReady) return;

      const gridConstrained = document.getElementById('gridConstrainedEdge').checked;
      const rows = parseInt(document.getElementById('rowsInput').value);
      const cols = parseInt(document.getElementById('colsInput').value);
      const cellWidth = spriteImage.width / cols;
      const cellHeight = spriteImage.height / rows;

      let rects = [];

      if (gridConstrained) {
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const x = col * cellWidth;
            const y = row * cellHeight;
            const cellCanvas = document.createElement('canvas');
            cellCanvas.width = cellWidth;
            cellCanvas.height = cellHeight;
            const cellCtx = cellCanvas.getContext('2d');
            cellCtx.drawImage(
              spriteImage,
              x, y, cellWidth, cellHeight,
              0, 0, cellWidth, cellHeight
            );

            const src = cv.imread(cellCanvas);
            const gray = new cv.Mat();
            const adjusted = new cv.Mat();
            const blurred = new cv.Mat();
            const edges = new cv.Mat();

            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            const contrast = parseFloat(document.getElementById('contrast').value);
            gray.convertTo(adjusted, -1, contrast, 0);
            const blurSize = parseInt(document.getElementById('blurAmount').value);
            cv.GaussianBlur(adjusted, blurred, new cv.Size(blurSize, blurSize), 0);
            cv.Canny(blurred, edges, parseInt(document.getElementById('threshold1').value), parseInt(document.getElementById('threshold2').value));

            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            const minContourArea = parseInt(document.getElementById('minContourArea').value);
            for (let i = 0; i < contours.size(); i++) {
              const contour = contours.get(i);
              const area = cv.contourArea(contour);
              if (area >= minContourArea) {
                const rect = cv.boundingRect(contour);
                rects.push({
                  x: rect.x + x,
                  y: rect.y + y,
                  width: rect.width,
                  height: rect.height
                });
              }
            }

            src.delete();
            gray.delete();
            adjusted.delete();
            blurred.delete();
            edges.delete();
            contours.delete();
            hierarchy.delete();
          }
        }
      } else {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = spriteImage.width;
        tempCanvas.height = spriteImage.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(spriteImage, 0, 0);

        const src = cv.imread(tempCanvas);
        const gray = new cv.Mat();
        const adjusted = new cv.Mat();
        const blurred = new cv.Mat();
        const edges = new cv.Mat();

        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        const contrast = parseFloat(document.getElementById('contrast').value);
        gray.convertTo(adjusted, -1, contrast, 0);
        const blurSize = parseInt(document.getElementById('blurAmount').value);
        cv.GaussianBlur(adjusted, blurred, new cv.Size(blurSize, blurSize), 0);
        cv.Canny(blurred, edges, parseInt(document.getElementById('threshold1').value), parseInt(document.getElementById('threshold2').value));

        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        const minContourArea = parseInt(document.getElementById('minContourArea').value);
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const area = cv.contourArea(contour);
          if (area >= minContourArea) {
            const rect = cv.boundingRect(contour);
            const gridX = Math.round(rect.x / cellWidth) * cellWidth;
            const gridY = Math.round(rect.y / cellHeight) * cellHeight;
            const gridWidth = Math.round((rect.x + rect.width) / cellWidth) * cellWidth - gridX;
            const gridHeight = Math.round((rect.y + rect.height) / cellHeight) * cellHeight - gridY;
            if (gridWidth > 0 && gridHeight > 0) {
              rects.push({
                x: gridX,
                y: gridY,
                width: gridWidth,
                height: gridHeight
              });
            }
          }
        }

        src.delete();
        gray.delete();
        adjusted.delete();
        blurred.delete();
        edges.delete();
        contours.delete();
        hierarchy.delete();
      }

      edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = spriteImage.width;
      tempCanvas.height = spriteImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(spriteImage, 0, 0);
      const src = cv.imread(tempCanvas);
      const gray = new cv.Mat();
      const adjusted = new cv.Mat();
      const blurred = new cv.Mat();
      const edges = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const contrast = parseFloat(document.getElementById('contrast').value);
      gray.convertTo(adjusted, -1, contrast, 0);
      const blurSize = parseInt(document.getElementById('blurAmount').value);
      cv.GaussianBlur(adjusted, blurred, new cv.Size(blurSize, blurSize), 0);
      cv.Canny(blurred, edges, parseInt(document.getElementById('threshold1').value), parseInt(document.getElementById('threshold2').value));
      const edgeMat = new cv.Mat();
      cv.cvtColor(edges, edgeMat, cv.COLOR_GRAY2RGBA);
      cv.imshow(edgeCanvas, edgeMat);
      edgeMat.delete();
      src.delete();
      gray.delete();
      adjusted.delete();
      blurred.delete();
      edges.delete();

      if (document.getElementById('mergeContours').checked) {
        const mergeDistance = parseInt(document.getElementById('mergeDistance').value);
        rects = mergeNearbyRects(rects, mergeDistance);
      }

      autoSelections = [];
      frames = [];
      rects.forEach((rect) => {
        autoSelections.push(rect);
        const frameCanvas = document.createElement('canvas');
        const frameCtx = frameCanvas.getContext('2d');
        frameCanvas.width = rect.width;
        frameCanvas.height = rect.height;
        frameCtx.drawImage(
          spriteImage,
          rect.x,
          rect.y,
          rect.width,
          rect.height,
          0,
          0,
          rect.width,
          rect.height
        );
        frames.push(frameCanvas.toDataURL('image/png'));
      });

      if (frames.length === 0) {
        status.textContent = 'No frames detected. Try adjusting the settings (e.g., lower thresholds, reduce blur, or increase min contour area).';
      } else {
        status.textContent = `Frames: ${frames.length}`;
      }

      updatePreview();
      drawCanvas();
    }

    function mergeNearbyRects(rects, mergeDistance) {
      let merged = [];
      let used = new Array(rects.length).fill(false);

      for (let i = 0; i < rects.length; i++) {
        if (used[i]) continue;
        let currentRect = { ...rects[i] };
        used[i] = true;

        for (let j = 0; j < rects.length; j++) {
          if (i === j || used[j]) continue;
          const otherRect = rects[j];
          const expandedRect = {
            x: currentRect.x - mergeDistance,
            y: currentRect.y - mergeDistance,
            width: currentRect.width + 2 * mergeDistance,
            height: currentRect.height + 2 * mergeDistance
          };

          if (
            otherRect.x >= expandedRect.x &&
            otherRect.x + otherRect.width <= expandedRect.x + expandedRect.width &&
            otherRect.y >= expandedRect.y &&
            otherRect.y + otherRect.height <= expandedRect.y + expandedRect.height
          ) {
            const minX = Math.min(currentRect.x, otherRect.x);
            const minY = Math.min(currentRect.y, otherRect.y);
            const maxX = Math.max(currentRect.x + currentRect.width, otherRect.x + otherRect.width);
            const maxY = Math.max(currentRect.y + currentRect.height, otherRect.y + otherRect.height);
            currentRect = {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
            used[j] = true;
            j = -1;
          }
        }
        merged.push(currentRect);
      }
      return merged;
    }

    function sliceWithGrid() {
      if (!spriteImage) {
        alert('Please upload a sprite sheet.');
        return;
      }

      const rows = parseInt(document.getElementById('rowsInput').value);
      const cols = parseInt(document.getElementById('colsInput').value);
      const cellWidth = spriteImage.width / cols;
      const cellHeight = spriteImage.height / rows;

      autoSelections = [];
      frames = [];
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const rect = {
            x: col * cellWidth,
            y: row * cellHeight,
            width: cellWidth,
            height: cellHeight
          };
          autoSelections.push(rect);
          const frameCanvas = document.createElement('canvas');
          const frameCtx = frameCanvas.getContext('2d');
          frameCanvas.width = cellWidth;
          frameCanvas.height = cellHeight;
          frameCtx.drawImage(
            spriteImage,
            rect.x,
            rect.y,
            cellWidth,
            cellHeight,
            0,
            0,
            cellWidth,
            cellHeight
          );
          frames.push(frameCanvas.toDataURL('image/png'));
        }
      }
      updatePreview();
      drawCanvas();
    }

    function updateZoom() {
      zoom = parseFloat(document.getElementById('zoomSlider').value);
      drawCanvas();
    }

    function updateManualTool() {
      manualTool = document.getElementById('manualTool').value;
      lassoPoints = [];
      isLassoDrawing = false;
      drawCanvas();
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (spriteImage) {
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.drawImage(spriteImage, 0, 0);
        ctx.restore();
      }

      const rows = parseInt(document.getElementById('rowsInput').value);
      const cols = parseInt(document.getElementById('colsInput').value);
      const cellWidth = canvas.width / cols;
      const cellHeight = canvas.height / rows;

      if ((mode === 'manual' && document.getElementById('showGrid').checked) || mode === 'auto' || mode === 'refine') {
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 1 / zoom;
        for (let row = 1; row < rows; row++) {
          ctx.beginPath();
          ctx.moveTo(0, row * cellHeight);
          ctx.lineTo(canvas.width, row * cellHeight);
          ctx.stroke();
        }
        for (let col = 1; col < cols; col++) {
          ctx.beginPath();
          ctx.moveTo(col * cellWidth, 0);
          ctx.lineTo(col * cellWidth, canvas.height);
          ctx.stroke();
        }
        ctx.restore();
      }

      const adjustCorners = document.getElementById('adjustCorners').checked;
      const selections = mode === 'manual' ? manualSelections : autoSelections;

      ctx.save();
      ctx.translate(panX, panY);
      ctx.scale(zoom, zoom);
      selections.forEach((selection, index) => {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.lineWidth = 2 / zoom;
        ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);
        ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
        ctx.font = `${12 / zoom}px monospace`;
        ctx.fillText(`Frame ${index + 1}`, selection.x + 5 / zoom, selection.y + 15 / zoom);

        if (adjustCorners) {
          const handleSize = 10 / zoom;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
          ctx.fillRect(selection.x - handleSize / 2, selection.y - handleSize / 2, handleSize, handleSize);
          ctx.fillRect(selection.x + selection.width - handleSize / 2, selection.y - handleSize / 2, handleSize, handleSize);
          ctx.fillRect(selection.x - handleSize / 2, selection.y + selection.height - handleSize / 2, handleSize, handleSize);
          ctx.fillRect(selection.x + selection.width - handleSize / 2, selection.y + selection.height - handleSize / 2, handleSize, handleSize);
        }
      });

      if (mode === 'manual' && manualTool === 'lasso' && lassoPoints.length > 0) {
        ctx.strokeStyle = lassoMode === 'add' ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
        ctx.lineWidth = 2 / zoom;
        ctx.beginPath();
        ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
        for (let i = 1; i < lassoPoints.length; i++) {
          ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
        }
        if (!isLassoDrawing) {
          ctx.closePath();
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (!spriteImage) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      const y = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      if (e.altKey) {
        isPanning = true;
        lastPanX = e.clientX;
        lastPanY = e.clientY;
        return;
      }

      const adjustCorners = document.getElementById('adjustCorners').checked;
      if (adjustCorners) {
        const selections = mode === 'manual' ? manualSelections : autoSelections;
        const handleSize = 10 / zoom;
        selectedCorner = null;
        selectedRectIndex = null;
        selectedArray = null;

        for (let i = 0; i < selections.length; i++) {
          const sel = selections[i];
          const corners = [
            { corner: 'top-left', x: sel.x, y: sel.y },
            { corner: 'top-right', x: sel.x + sel.width, y: sel.y },
            { corner: 'bottom-left', x: sel.x, y: sel.y + sel.height },
            { corner: 'bottom-right', x: sel.x + sel.width, y: sel.y + sel.height }
          ];
          for (const corner of corners) {
            const distX = x - corner.x;
            const distY = y - corner.y;
            if (Math.abs(distX) <= handleSize && Math.abs(distY) <= handleSize) {
              selectedCorner = corner.corner;
              selectedRectIndex = i;
              selectedArray = mode === 'manual' ? manualSelections : autoSelections;
              isDragging = true;
              break;
            }
          }
          if (isDragging) break;
        }
      }

      if (!isDragging && mode === 'manual') {
        startX = x;
        startY = y;
        if (manualTool === 'lasso') {
          lassoPoints = [{ x, y }];
          isLassoDrawing = true;
          lassoMode = e.shiftKey ? 'add' : (e.ctrlKey || e.metaKey) ? 'subtract' : 'add';
        } else if (document.getElementById('snapToGrid').checked) {
          const rows = parseInt(document.getElementById('rowsInput').value);
          const cols = parseInt(document.getElementById('colsInput').value);
          const cellWidth = spriteImage.width / cols;
          const cellHeight = spriteImage.height / rows;
          startX = Math.round(startX / cellWidth) * cellWidth;
          startY = Math.round(startY / cellHeight) * cellHeight;
        }
        isDragging = true;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      const y = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      if (isPanning) {
        const dx = e.clientX - lastPanX;
        const dy = e.clientY - lastPanY;
        panX += dx;
        panY += dy;
        lastPanX = e.clientX;
        lastPanY = e.clientY;
        drawCanvas();
        return;
      }

      if (isDragging && selectedRectIndex !== null && selectedCorner !== null && selectedArray !== null) {
        const sel = selectedArray[selectedRectIndex];
        let newX = sel.x;
        let newY = sel.y;
        let newWidth = sel.width;
        let newHeight = sel.height;

        const rows = parseInt(document.getElementById('rowsInput').value);
        const cols = parseInt(document.getElementById('colsInput').value);
        const cellWidth = spriteImage.width / cols;
        const cellHeight = spriteImage.height / rows;
        let snappedX = Math.round(x / cellWidth) * cellWidth;
        let snappedY = Math.round(y / cellHeight) * cellHeight;

        if (selectedCorner === 'top-left') {
          newWidth = (sel.x + sel.width) - snappedX;
          newHeight = (sel.y + sel.height) - snappedY;
          newX = snappedX;
          newY = snappedY;
        } else if (selectedCorner === 'top-right') {
          newWidth = snappedX - sel.x;
          newHeight = (sel.y + sel.height) - snappedY;
          newY = snappedY;
        } else if (selectedCorner === 'bottom-left') {
          newWidth = (sel.x + sel.width) - snappedX;
          newHeight = snappedY - sel.y;
          newX = snappedX;
        } else if (selectedCorner === 'bottom-right') {
          newWidth = snappedX - sel.x;
          newHeight = snappedY - sel.y;
        }

        if (newWidth > 5 && newHeight > 5 && newX >= 0 && newY >= 0 && (newX + newWidth) <= spriteImage.width && (newY + newHeight) <= spriteImage.height) {
          selectedArray[selectedRectIndex] = {
            x: newX,
            y: newY,
            width: newWidth,
            height: newHeight
          };
          updateFrame(selectedRectIndex);
        }
        drawCanvas();
      } else if (isDragging && mode === 'manual') {
        if (manualTool === 'lasso' && isLassoDrawing) {
          lassoPoints.push({ x, y });
          drawCanvas();
        } else if (manualTool === 'rectangle') {
          let endX = x;
          let endY = y;
          if (document.getElementById('snapToGrid').checked) {
            const rows = parseInt(document.getElementById('rowsInput').value);
            const cols = parseInt(document.getElementById('colsInput').value);
            const cellWidth = spriteImage.width / cols;
            const cellHeight = spriteImage.height / rows;
            endX = Math.round(endX / cellWidth) * cellWidth;
            endY = Math.round(endY / cellHeight) * cellHeight;
          }
          drawCanvas();
          ctx.save();
          ctx.translate(panX, panY);
          ctx.scale(zoom, zoom);
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
          ctx.lineWidth = 2 / zoom;
          ctx.strokeRect(startX, startY, endX - startX, endY - startY);
          ctx.restore();
        }
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (isPanning) {
        isPanning = false;
        return;
      }

      if (isDragging && selectedRectIndex !== null) {
        isDragging = false;
        selectedCorner = null;
        selectedRectIndex = null;
        selectedArray = null;
        drawCanvas();
        return;
      }

      if (!isDragging || mode !== 'manual') return;
      const rect = canvas.getBoundingClientRect();
      let endX = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      let endY = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      if (manualTool === 'lasso') {
        isLassoDrawing = false;
        if (lassoPoints.length > 2) {
          const minX = Math.min(...lassoPoints.map(p => p.x));
          const maxX = Math.max(...lassoPoints.map(p => p.x));
          const minY = Math.min(...lassoPoints.map(p => p.y));
          const maxY = Math.max(...lassoPoints.map(p => p.y));
          const width = maxX - minX;
          const height = maxY - minY;

          if (width > 5 && height > 5) {
            const lassoRect = { x: minX, y: minY, width, height };

            if (lassoMode === 'add') {
              const selection = {
                x: minX,
                y: minY,
                width: width,
                height: height
              };
              manualSelections.push(selection);
              const frameCanvas = document.createElement('canvas');
              const frameCtx = frameCanvas.getContext('2d');
              frameCanvas.width = width;
              frameCanvas.height = height;
              frameCtx.drawImage(
                spriteImage,
                selection.x,
                selection.y,
                width,
                height,
                0,
                0,
                width,
                height
              );
              frames.push(frameCanvas.toDataURL('image/png'));
            } else if (lassoMode === 'subtract') {
              const newSelections = [];
              const newFrames = [];
              manualSelections.forEach((sel, idx) => {
                const selRight = sel.x + sel.width;
                const selBottom = sel.y + sel.height;
                const lassoRight = lassoRect.x + lassoRect.width;
                const lassoBottom = lassoRect.y + lassoRect.height;

                const doesNotOverlap = (
                  selRight < lassoRect.x ||
                  sel.x > lassoRight ||
                  selBottom < lassoRect.y ||
                  sel.y > lassoBottom
                );

                if (doesNotOverlap) {
                  newSelections.push(sel);
                  newFrames.push(frames[idx]);
                }
              });
              manualSelections = newSelections;
              frames = newFrames;
            }
            updatePreview();
          }
        }
        lassoPoints = [];
      } else if (manualTool === 'rectangle') {
        if (document.getElementById('snapToGrid').checked) {
          const rows = parseInt(document.getElementById('rowsInput').value);
          const cols = parseInt(document.getElementById('colsInput').value);
          const cellWidth = spriteImage.width / cols;
          const cellHeight = spriteImage.height / rows;
          endX = Math.round(endX / cellWidth) * cellWidth;
          endY = Math.round(endY / cellHeight) * cellHeight;
        }

        const width = Math.abs(endX - startX);
        const height = Math.abs(endY - startY);
        if (width > 5 && height > 5) {
          const selection = {
            x: Math.min(startX, endX),
            y: Math.min(startY, endY),
            width: width,
            height: height
          };
          manualSelections.push(selection);

          const frameCanvas = document.createElement('canvas');
          const frameCtx = frameCanvas.getContext('2d');
          frameCanvas.width = width;
          frameCanvas.height = height;
          frameCtx.drawImage(
            spriteImage,
            selection.x,
            selection.y,
            width,
            height,
            0,
            0,
            width,
            height
          );
          frames.push(frameCanvas.toDataURL('image/png'));
          updatePreview();
        }
      }
      isDragging = false;
      drawCanvas();
    });

    canvas.addEventListener('wheel', (e) => {
      if (mode !== 'manual' || !spriteImage) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoom = Math.max(0.5, Math.min(3, zoom + delta));
      document.getElementById('zoomSlider').value = zoom;
      drawCanvas();
    });

    function updateFrame(index) {
      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const rect = selections[index];
      const frameCanvas = document.createElement('canvas');
      const frameCtx = frameCanvas.getContext('2d');
      frameCanvas.width = rect.width;
      frameCanvas.height = rect.height;
      frameCtx.drawImage(
        spriteImage,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height
      );
      frames[index] = frameCanvas.toDataURL('image/png');
      updatePreview();
    }

    function undoLastSelection() {
      if (mode !== 'manual' || manualSelections.length === 0) return;
      manualSelections.pop();
      frames.pop();
      updatePreview();
      drawCanvas();
    }

    function updatePreview() {
      previewSection.innerHTML = '';
      frames.forEach((frameData, index) => {
        const frameImg = document.createElement('img');
        frameImg.src = frameData;
        frameImg.title = `Frame ${index + 1}`;
        frameImg.draggable = true;
        frameImg.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', index);
          frameImg.classList.add('dragging');
        });
        frameImg.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        frameImg.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          if (fromIndex !== toIndex) {
            const [movedFrame] = frames.splice(fromIndex, 1);
            frames.splice(toIndex, 0, movedFrame);
            if (mode === 'manual') {
              const [movedSelection] = manualSelections.splice(fromIndex, 1);
              manualSelections.splice(toIndex, 0, movedSelection);
            } else {
              const [movedSelection] = autoSelections.splice(fromIndex, 1);
              autoSelections.splice(toIndex, 0, movedSelection);
            }
            updatePreview();
            drawCanvas();
          }
        });
        frameImg.addEventListener('dragend', () => {
          frameImg.classList.remove('dragging');
        });
        frameImg.addEventListener('click', (e) => {
          if (e.shiftKey) {
            openSelectionWindow(index);
          } else {
            frames.splice(index, 1);
            if (mode === 'manual') manualSelections.splice(index, 1);
            else autoSelections.splice(index, 1);
            updatePreview();
            drawCanvas();
          }
        });
        previewSection.appendChild(frameImg);
      });
      status.textContent = frames.length === 0 ? status.textContent : `Frames: ${frames.length}`;
    }

    function openSelectionWindow(index) {
      currentSelectionIndex = index;
      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const rect = selections[index];
      selectionCanvas.width = rect.width;
      selectionCanvas.height = rect.height;
      selectionCropRect = { x: 0, y: 0, width: rect.width, height: rect.height };
      setupCornerHandles();
      drawSelectionCanvas();
      selectionWindow.style.display = 'flex';
    }

    function setupCornerHandles() {
      cornerHandles.innerHTML = '';
      const offset = 5; // Offset handles outside the crop rectangle
      const corners = [
        { id: 'top-left', x: selectionCropRect.x - offset, y: selectionCropRect.y - offset },
        { id: 'top-right', x: selectionCropRect.x + selectionCropRect.width + offset - 10, y: selectionCropRect.y - offset },
        { id: 'bottom-left', x: selectionCropRect.x - offset, y: selectionCropRect.y + selectionCropRect.height + offset - 10 },
        { id: 'bottom-right', x: selectionCropRect.x + selectionCropRect.width + offset - 10, y: selectionCropRect.y + selectionCropRect.height + offset - 10 }
      ];

      corners.forEach(corner => {
        const handle = document.createElement('div');
        handle.className = `corner-handle ${corner.id}`;
        handle.style.left = `${corner.x}px`;
        handle.style.top = `${corner.y}px`;
        handle.dataset.corner = corner.id;
        handle.title = `Drag to adjust ${corner.id} corner`;
        handle.draggable = true;
        handle.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', corner.id);
          handle.classList.add('dragging');
        });
        handle.addEventListener('dragend', () => {
          handle.classList.remove('dragging');
        });
        cornerHandles.appendChild(handle);
      });

      selectionCanvas.addEventListener('dragover', (e) => e.preventDefault());
      selectionCanvas.addEventListener('drop', (e) => {
        e.preventDefault();
        const cornerId = e.dataTransfer.getData('text/plain');
        const rect = selectionCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let newX = selectionCropRect.x;
        let newY = selectionCropRect.y;
        let newWidth = selectionCropRect.width;
        let newHeight = selectionCropRect.height;

        if (cornerId === 'top-left') {
          newWidth = (selectionCropRect.x + selectionCropRect.width) - x;
          newHeight = (selectionCropRect.y + selectionCropRect.height) - y;
          newX = x;
          newY = y;
        } else if (cornerId === 'top-right') {
          newWidth = x - selectionCropRect.x;
          newHeight = (selectionCropRect.y + selectionCropRect.height) - y;
          newY = y;
        } else if (cornerId === 'bottom-left') {
          newWidth = (selectionCropRect.x + selectionCropRect.width) - x;
          newHeight = y - selectionCropRect.y;
          newX = x;
        } else if (cornerId === 'bottom-right') {
          newWidth = x - selectionCropRect.x;
          newHeight = y - selectionCropRect.y;
        }

        if (newWidth > 5 && newHeight > 5 && newX >= 0 && newY >= 0 && (newX + newWidth) <= selectionCanvas.width && (newY + newHeight) <= selectionCanvas.height) {
          selectionCropRect = { x: newX, y: newY, width: newWidth, height: newHeight };
          setupCornerHandles();
          drawSelectionCanvas();
        }
      });

      drawSelectionCanvas();
    }

    function drawSelectionCanvas() {
      selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const rect = selections[currentSelectionIndex];
      selectionCtx.drawImage(
        spriteImage,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height
      );

      // Draw semi-transparent overlay outside the crop area
      selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);
      selectionCtx.clearRect(selectionCropRect.x, selectionCropRect.y, selectionCropRect.width, selectionCropRect.height);

      // Draw the crop rectangle border
      selectionCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
      selectionCtx.lineWidth = 2;
      selectionCtx.strokeRect(selectionCropRect.x, selectionCropRect.y, selectionCropRect.width, selectionCropRect.height);
    }

    function cropSelection() {
      if (currentSelectionIndex === null) return;
      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const rect = selections[currentSelectionIndex];
      const newX = rect.x + selectionCropRect.x;
      const newY = rect.y + selectionCropRect.y;
      const newWidth = selectionCropRect.width;
      const newHeight = selectionCropRect.height;

      selections[currentSelectionIndex] = {
        x: newX,
        y: newY,
        width: newWidth,
        height: newHeight
      };

      const frameCanvas = document.createElement('canvas');
      const frameCtx = frameCanvas.getContext('2d');
      frameCanvas.width = newWidth;
      frameCanvas.height = newHeight;
      frameCtx.drawImage(
        spriteImage,
        newX,
        newY,
        newWidth,
        newHeight,
        0,
        0,
        newWidth,
        newHeight
      );
      frames[currentSelectionIndex] = frameCanvas.toDataURL('image/png');

      drawCanvas();
      updatePreview();
      closeSelectionWindow();
    }

    function closeSelectionWindow() {
      selectionWindow.style.display = 'none';
      currentSelectionIndex = null;
      selectionCropRect = null;
      cornerHandles.innerHTML = '';
    }

    function openFinishingWindow() {
      if (frames.length === 0) {
        alert('No frames to process. Please create some frames first.');
        return;
      }
      document.getElementById('scaleFactor').value = 1;
      updateScaleFactorValue();
      finishingWindow.style.display = 'flex';
      updateFinishingPreview();
    }

    function toggleCustomSize() {
      const template = document.getElementById('frameSizeTemplate').value;
      const customSizeInputs = document.getElementById('customSizeInputs');
      customSizeInputs.style.display = template === 'custom' ? 'block' : 'none';
      updateFinishingPreview();
    }

    function updateScaleFactorValue() {
      const scaleFactor = parseFloat(document.getElementById('scaleFactor').value);
      document.getElementById('scaleFactorValue').textContent = `${scaleFactor.toFixed(1)}x`;
    }

    function updateFinishingPreview() {
      if (frames.length === 0) return;

      const template = document.getElementById('frameSizeTemplate').value;
      let newWidth, newHeight;
      switch (template) {
        case 'gameboy_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'nes_8x8':
          newWidth = 8;
          newHeight = 8;
          break;
        case 'nes_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'snes_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'snes_32x32':
          newWidth = 32;
          newHeight = 32;
          break;
        case 'snes_64x64':
          newWidth = 64;
          newHeight = 64;
          break;
        case 'genesis_32x32':
          newWidth = 32;
          newHeight = 32;
          break;
        case 'custom':
          newWidth = parseInt(document.getElementById('customWidth').value) || 16;
          newHeight = parseInt(document.getElementById('customHeight').value) || 16;
          break;
        default:
          newWidth = 16;
          newHeight = 16;
      }

      const scaleFactor = parseFloat(document.getElementById('scaleFactor').value);
      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const rect = selections[0]; // Preview the first frame
      const frameImg = new Image();
      frameImg.src = frames[0];
      frameImg.onload = () => {
        finishingPreviewCanvas.width = newWidth;
        finishingPreviewCanvas.height = newHeight;
        finishingPreviewCtx.clearRect(0, 0, newWidth, newHeight);

        const scaledWidth = rect.width * scaleFactor;
        const scaledHeight = rect.height * scaleFactor;
        const offsetX = (newWidth - scaledWidth) / 2;
        const offsetY = (newHeight - scaledHeight) / 2;

        finishingPreviewCtx.drawImage(
          frameImg,
          0,
          0,
          rect.width,
          rect.height,
          offsetX,
          offsetY,
          scaledWidth,
          scaledHeight
        );

        // Draw a border to indicate the frame size
        finishingPreviewCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        finishingPreviewCtx.lineWidth = 1;
        finishingPreviewCtx.strokeRect(0, 0, newWidth, newHeight);
      };
    }

    function applyFinishing() {
      const template = document.getElementById('frameSizeTemplate').value;
      let newWidth, newHeight;
      switch (template) {
        case 'gameboy_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'nes_8x8':
          newWidth = 8;
          newHeight = 8;
          break;
        case 'nes_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'snes_16x16':
          newWidth = 16;
          newHeight = 16;
          break;
        case 'snes_32x32':
          newWidth = 32;
          newHeight = 32;
          break;
        case 'snes_64x64':
          newWidth = 64;
          newHeight = 64;
          break;
        case 'genesis_32x32':
          newWidth = 32;
          newHeight = 32;
          break;
        case 'custom':
          newWidth = parseInt(document.getElementById('customWidth').value) || 16;
          newHeight = parseInt(document.getElementById('customHeight').value) || 16;
          break;
        default:
          newWidth = 16;
          newHeight = 16;
      }

      const scaleFactor = parseFloat(document.getElementById('scaleFactor').value);
      const selections = mode === 'manual' ? manualSelections : autoSelections;

      frames = frames.map((frameData, index) => {
        const rect = selections[index];
        const frameImg = new Image();
        frameImg.src = frameData;
        const frameCanvas = document.createElement('canvas');
        const frameCtx = frameCanvas.getContext('2d');
        frameCanvas.width = newWidth;
        frameCanvas.height = newHeight;

        const scaledWidth = rect.width * scaleFactor;
        const scaledHeight = rect.height * scaleFactor;
        const offsetX = (newWidth - scaledWidth) / 2;
        const offsetY = (newHeight - scaledHeight) / 2;

        frameCtx.drawImage(
          frameImg,
          0,
          0,
          rect.width,
          rect.height,
          offsetX,
          offsetY,
          scaledWidth,
          scaledHeight
        );

        // Update the selection dimensions (x and y remain the same as they refer to the sprite sheet)
        selections[index].width = newWidth;
        selections[index].height = newHeight;

        return frameCanvas.toDataURL('image/png');
      });

      updatePreview();
      closeFinishingWindow();
    }

    function closeFinishingWindow() {
      finishingWindow.style.display = 'none';
    }

    function exportAsZip() {
      if (frames.length === 0) {
        alert('No frames to export!');
        return;
      }

      const zip = new JSZip();
      const selections = mode === 'manual' ? manualSelections : autoSelections;

      // Add frames to the ZIP
      frames.forEach((frameData, index) => {
        const base64Data = frameData.split(',')[1];
        const fileName = `frame_${String(index + 1).padStart(3, '0')}.png`;
        zip.file(fileName, base64Data, { base64: true });
      });

      // Add metadata as JSON
      const exportData = frames.map((frameData, index) => ({
        frame: `frame_${String(index + 1).padStart(3, '0')}.png`,
        metadata: {
          index: index + 1,
          x: selections[index].x,
          y: selections[index].y,
          width: selections[index].width,
          height: selections[index].height
        }
      }));
      zip.file('metadata.json', JSON.stringify(exportData, null, 2));

      // Generate and download the ZIP
      zip.generateAsync({ type: 'blob' }).then((content) => {
        saveAs(content, 'sprite_frames.zip');
      });
    }

    function exportToBigGifs() {
      if (frames.length === 0) {
        alert('No frames to export!');
        return;
      }

      const selections = mode === 'manual' ? manualSelections : autoSelections;
      const exportData = frames.map((frameData, index) => ({
        frame: frameData,
        metadata: {
          index: index + 1,
          x: selections[index].x,
          y: selections[index].y,
          width: selections[index].width,
          height: selections[index].height
        }
      }));

      alert('Exporting to BIG GIFS LAB:\n' + JSON.stringify(exportData, null, 2));
      console.log('Exported frames with metadata:', exportData);
    }
  </script>
</body>
</html>