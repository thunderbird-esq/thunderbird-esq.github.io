<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SPRITE SLICER - Thunderbird OS</title>
  <script async src="/src/lib/opencv.js" onload="onOpenCvReady()"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: #0ff;
      font-family: monospace;
      font-size: 14px;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: auto;
    }
    .container {
      width: 1024px;
      height: 1024px;
      background: #222;
      border: 2px solid #0ff;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: auto;
    }
    h1 {
      margin: 0 0 20px;
      font-size: 24px;
      text-align: center;
    }
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    .mode-toggle {
      margin-bottom: 10px;
    }
    .mode-toggle label {
      margin: 0 5px;
    }
    .mode-toggle input[type="radio"] {
      margin: 0 2px;
    }
    .auto-controls, .manual-controls {
      display: none;
      margin: 10px 0;
      width: 100%;
      max-width: 600px;
      background: #111;
      padding: 10px;
      border: 1px solid #0ff;
    }
    .auto-controls label, .manual-controls label {
      display: block;
      margin: 5px 0;
    }
    .auto-controls input[type="range"], .manual-controls input[type="range"] {
      width: 150px;
      margin: 0 5px;
    }
    .auto-controls input[type="number"] {
      width: 60px;
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px;
      margin: 0 5px;
    }
    .controls input[type="file"] {
      display: block;
      margin: 10px auto;
      color: #0ff;
      background: #111;
      border: 1px solid #0ff;
      padding: 5px;
    }
    .controls button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
      margin: 5px;
    }
    .canvas-container {
      position: relative;
      margin-bottom: 20px;
      display: flex;
      gap: 20px;
    }
    canvas {
      border: 1px solid #0ff;
      max-width: 100%;
      max-height: 400px;
    }
    #edgeCanvas {
      border: 1px solid #f00;
      max-width: 100%;
      max-height: 400px;
    }
    .status {
      margin-bottom: 10px;
      text-align: center;
    }
    .preview-section {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
      max-height: 200px;
      overflow-y: auto;
    }
    .preview-section img {
      border: 1px solid #0ff;
      max-width: 100px;
      max-height: 100px;
      cursor: pointer;
    }
    .preview-section img:hover {
      border-color: #f00;
    }
    .preview-section img.dragging {
      opacity: 0.5;
    }
    .action-section {
      text-align: center;
    }
    .action-section button {
      background: #111;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>SPRITE SLICER</h1>
    <div class="controls">
      <div class="mode-toggle">
        <label><input type="radio" name="mode" value="auto" checked onclick="toggleMode()"> Auto Mode</label>
        <label><input type="radio" name="mode" value="manual" onclick="toggleMode()"> Manual Mode</label>
      </div>
      <input type="file" id="spriteSheetInput" accept="image/*">
      <div class="auto-controls" id="autoControls">
        <h3>Edge Detection Settings</h3>
        <label title="Apply Gaussian blur to reduce noise before edge detection">
          Blur Amount: <input type="range" id="blurAmount" min="1" max="15" step="2" value="3" oninput="autoSlice()">
        </label>
        <label title="Lower threshold for Canny edge detection (more edges if lower)">
          Edge Threshold 1: <input type="range" id="threshold1" min="0" max="255" value="50" oninput="autoSlice()">
        </label>
        <label title="Upper threshold for Canny edge detection (fewer edges if higher)">
          Edge Threshold 2: <input type="range" id="threshold2" min="0" max="255" value="150" oninput="autoSlice()">
        </label>
        <label title="Minimum area (in pixels) for a contour to be considered a frame">
          Min Contour Area: <input type="range" id="minContourArea" min="100" max="5000" value="100" oninput="autoSlice()">
        </label>
        <label title="Merge nearby contours into a single frame">
          <input type="checkbox" id="mergeContours" checked onchange="autoSlice()"> Merge Nearby Contours
        </label>
        <label title="Distance (in pixels) for merging nearby contours">
          Merge Distance: <input type="range" id="mergeDistance" min="0" max="50" value="10" oninput="autoSlice()">
        </label>
        <h3>Grid Fallback (if edge detection fails)</h3>
        <label title="Number of rows for grid-based slicing">
          Rows: <input type="number" id="rowsInput" min="1" value="1">
        </label>
        <label title="Number of columns for grid-based slicing">
          Columns: <input type="number" id="colsInput" min="1" value="1">
        </label>
        <button onclick="sliceWithGrid()">Use Grid Slicing</button>
        <button onclick="resetSettings()">Reset to Defaults</button>
      </div>
      <div class="manual-controls" id="manualControls">
        <label>Zoom: <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="1" oninput="updateZoom()"></label>
        <button onclick="undoLastSelection()">Undo Last Selection</button>
      </div>
    </div>
    <div class="status" id="status">Frames: 0</div>
    <div class="canvas-container">
      <canvas id="spriteCanvas"></canvas>
      <canvas id="edgeCanvas"></canvas>
    </div>
    <div class="preview-section" id="previewSection"></div>
    <div class="action-section">
      <button onclick="exportToBigGifs()">Export to BIG GIFS LAB</button>
    </div>
  </div>

  <script>
    let mode = 'auto';
    let spriteImage = null;
    let frames = [];
    let manualSelections = [];
    let autoSelections = [];
    let isDragging = false;
    let startX, startY;
    let zoom = 1;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let lastPanX, lastPanY;
    let opencvReady = false;
    const canvas = document.getElementById('spriteCanvas');
    const ctx = canvas.getContext('2d');
    const edgeCanvas = document.getElementById('edgeCanvas');
    const edgeCtx = edgeCanvas.getContext('2d');
    const previewSection = document.getElementById('previewSection');
    const status = document.getElementById('status');

    const defaultSettings = {
      blurAmount: 3,
      threshold1: 50,
      threshold2: 150,
      minContourArea: 100,
      mergeContours: true,
      mergeDistance: 10,
      rows: 1,
      cols: 1
    };

    function onOpenCvReady() {
      opencvReady = true;
      console.log('OpenCV.js is ready');
    }

    function toggleMode() {
      mode = document.querySelector('input[name="mode"]:checked').value;
      document.getElementById('autoControls').style.display = mode === 'auto' ? 'block' : 'none';
      document.getElementById('manualControls').style.display = mode === 'manual' ? 'block' : 'none';
      manualSelections = [];
      frames = [];
      zoom = 1;
      panX = 0;
      panY = 0;
      document.getElementById('zoomSlider').value = 1;
      updatePreview();
      if (spriteImage) {
        if (mode === 'auto') autoSlice();
        drawCanvas();
      }
    }

    document.getElementById('spriteSheetInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        spriteImage = new Image();
        spriteImage.src = URL.createObjectURL(file);
        spriteImage.onload = () => {
          canvas.width = spriteImage.width;
          canvas.height = spriteImage.height;
          edgeCanvas.width = spriteImage.width;
          edgeCanvas.height = spriteImage.height;
          zoom = 1;
          panX = 0;
          panY = 0;
          // Suggest grid dimensions based on image size
          const suggestedRows = Math.max(1, Math.round(spriteImage.height / 32));
          const suggestedCols = Math.max(1, Math.round(spriteImage.width / 32));
          document.getElementById('rowsInput').value = suggestedRows;
          document.getElementById('colsInput').value = suggestedCols;
          drawCanvas();
          if (mode === 'auto' && opencvReady) autoSlice();
        };
      }
    });

    function resetSettings() {
      document.getElementById('blurAmount').value = defaultSettings.blurAmount;
      document.getElementById('threshold1').value = defaultSettings.threshold1;
      document.getElementById('threshold2').value = defaultSettings.threshold2;
      document.getElementById('minContourArea').value = defaultSettings.minContourArea;
      document.getElementById('mergeContours').checked = defaultSettings.mergeContours;
      document.getElementById('mergeDistance').value = defaultSettings.mergeDistance;
      document.getElementById('rowsInput').value = defaultSettings.rows;
      document.getElementById('colsInput').value = defaultSettings.cols;
      if (spriteImage && mode === 'auto') autoSlice();
    }

    function autoSlice() {
      if (!spriteImage || !opencvReady) return;

      // Create a temporary canvas to process the image
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = spriteImage.width;
      tempCanvas.height = spriteImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(spriteImage, 0, 0);

      // Convert canvas to OpenCV Mat
      const src = cv.imread(tempCanvas);
      const gray = new cv.Mat();
      const blurred = new cv.Mat();
      const edges = new cv.Mat();

      // Preprocessing: Convert to grayscale and apply blur
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const blurSize = parseInt(document.getElementById('blurAmount').value);
      cv.GaussianBlur(gray, blurred, new cv.Size(blurSize, blurSize), 0);

      // Apply Canny edge detection
      cv.Canny(blurred, edges, parseInt(document.getElementById('threshold1').value), parseInt(document.getElementById('threshold2').value));

      // Display edges on the edge canvas
      edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
      const edgeMat = new cv.Mat();
      cv.cvtColor(edges, edgeMat, cv.COLOR_GRAY2RGBA);
      cv.imshow(edgeCanvas, edgeMat);
      edgeMat.delete();

      // Find contours
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      // Process contours to find bounding rectangles
      let rects = [];
      const minContourArea = parseInt(document.getElementById('minContourArea').value);
      for (let i = 0; i < contours.size(); i++) {
        const contour = contours.get(i);
        const area = cv.contourArea(contour);
        if (area >= minContourArea) {
          const rect = cv.boundingRect(contour);
          rects.push(rect);
        }
      }

      // Merge nearby contours if enabled
      if (document.getElementById('mergeContours').checked) {
        const mergeDistance = parseInt(document.getElementById('mergeDistance').value);
        rects = mergeNearbyRects(rects, mergeDistance);
      }

      // Convert merged rectangles to selections
      autoSelections = [];
      frames = [];
      rects.forEach((rect) => {
        autoSelections.push(rect);
        const frameCanvas = document.createElement('canvas');
        const frameCtx = frameCanvas.getContext('2d');
        frameCanvas.width = rect.width;
        frameCanvas.height = rect.height;
        frameCtx.drawImage(
          spriteImage,
          rect.x,
          rect.y,
          rect.width,
          rect.height,
          0,
          0,
          rect.width,
          rect.height
        );
        frames.push(frameCanvas.toDataURL('image/png'));
      });

      // Update status with feedback
      if (frames.length === 0) {
        status.textContent = 'No frames detected. Try adjusting the settings (e.g., lower thresholds, reduce blur, or increase min contour area).';
      } else {
        status.textContent = `Frames: ${frames.length}`;
      }

      // Clean up
      src.delete();
      gray.delete();
      blurred.delete();
      edges.delete();
      contours.delete();
      hierarchy.delete();

      updatePreview();
      drawCanvas();
    }

    function mergeNearbyRects(rects, mergeDistance) {
      let merged = [];
      let used = new Array(rects.length).fill(false);

      for (let i = 0; i < rects.length; i++) {
        if (used[i]) continue;
        let currentRect = { ...rects[i] };
        used[i] = true;

        for (let j = 0; j < rects.length; j++) {
          if (i === j || used[j]) continue;
          const otherRect = rects[j];
          const expandedRect = {
            x: currentRect.x - mergeDistance,
            y: currentRect.y - mergeDistance,
            width: currentRect.width + 2 * mergeDistance,
            height: currentRect.height + 2 * mergeDistance
          };

          if (
            otherRect.x >= expandedRect.x &&
            otherRect.x + otherRect.width <= expandedRect.x + expandedRect.width &&
            otherRect.y >= expandedRect.y &&
            otherRect.y + otherRect.height <= expandedRect.y + expandedRect.height
          ) {
            // Merge the rectangles
            const minX = Math.min(currentRect.x, otherRect.x);
            const minY = Math.min(currentRect.y, otherRect.y);
            const maxX = Math.max(currentRect.x + currentRect.width, otherRect.x + otherRect.width);
            const maxY = Math.max(currentRect.y + currentRect.height, otherRect.y + otherRect.height);
            currentRect = {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
            used[j] = true;
            j = -1; // Restart the loop to check for more merges
          }
        }
        merged.push(currentRect);
      }
      return merged;
    }

    function sliceWithGrid() {
      if (!spriteImage) {
        alert('Please upload a sprite sheet.');
        return;
      }

      const rows = parseInt(document.getElementById('rowsInput').value);
      const cols = parseInt(document.getElementById('colsInput').value);
      const cellWidth = spriteImage.width / cols;
      const cellHeight = spriteImage.height / rows;

      autoSelections = [];
      frames = [];
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const rect = {
            x: col * cellWidth,
            y: row * cellHeight,
            width: cellWidth,
            height: cellHeight
          };
          autoSelections.push(rect);
          const frameCanvas = document.createElement('canvas');
          const frameCtx = frameCanvas.getContext('2d');
          frameCanvas.width = cellWidth;
          frameCanvas.height = cellHeight;
          frameCtx.drawImage(
            spriteImage,
            rect.x,
            rect.y,
            cellWidth,
            cellHeight,
            0,
            0,
            cellWidth,
            cellHeight
          );
          frames.push(frameCanvas.toDataURL('image/png'));
        }
      }
      updatePreview();
      drawCanvas();
    }

    function updateZoom() {
      zoom = parseFloat(document.getElementById('zoomSlider').value);
      drawCanvas();
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (spriteImage) {
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.drawImage(spriteImage, 0, 0);
        ctx.restore();
      }

      if (mode === 'auto') {
        // Draw auto-detected selections
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        autoSelections.forEach((selection, index) => {
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
          ctx.lineWidth = 2 / zoom;
          ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);
          ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
          ctx.font = `${12 / zoom}px monospace`;
          ctx.fillText(`Frame ${index + 1}`, selection.x + 5 / zoom, selection.y + 15 / zoom);
        });
        ctx.restore();
      } else {
        // Draw manual selections with bounding boxes and labels
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        manualSelections.forEach((selection, index) => {
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
          ctx.lineWidth = 2 / zoom;
          ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);
          ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
          ctx.font = `${12 / zoom}px monospace`;
          ctx.fillText(`Frame ${index + 1}`, selection.x + 5 / zoom, selection.y + 15 / zoom);
        });
        ctx.restore();
      }
    }

    canvas.addEventListener('mousedown', (e) => {
      if (mode !== 'manual' || !spriteImage) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      const y = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      if (e.altKey) { // Alt + click to pan
        isPanning = true;
        lastPanX = e.clientX;
        lastPanY = e.clientY;
      } else {
        startX = x;
        startY = y;
        isDragging = true;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      const y = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      if (isPanning) {
        const dx = e.clientX - lastPanX;
        const dy = e.clientY - lastPanY;
        panX += dx;
        panY += dy;
        lastPanX = e.clientX;
        lastPanY = e.clientY;
        drawCanvas();
      } else if (isDragging && mode === 'manual') {
        drawCanvas();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.lineWidth = 2 / zoom;
        ctx.strokeRect(startX, startY, x - startX, y - startY);
        ctx.restore();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (isPanning) {
        isPanning = false;
        return;
      }
      if (!isDragging || mode !== 'manual') return;
      const rect = canvas.getBoundingClientRect();
      const endX = (e.clientX - rect.left) * (canvas.width / rect.width) / zoom - panX / zoom;
      const endY = (e.clientY - rect.top) * (canvas.height / rect.height) / zoom - panY / zoom;

      const width = Math.abs(endX - startX);
      const height = Math.abs(endY - startY);
      if (width > 5 && height > 5) { // Minimum size to avoid accidental clicks
        const selection = {
          x: Math.min(startX, endX),
          y: Math.min(startY, endY),
          width: width,
          height: height
        };
        manualSelections.push(selection);

        const frameCanvas = document.createElement('canvas');
        const frameCtx = frameCanvas.getContext('2d');
        frameCanvas.width = width;
        frameCanvas.height = height;
        frameCtx.drawImage(
          spriteImage,
          selection.x,
          selection.y,
          width,
          height,
          0,
          0,
          width,
          height
        );
        frames.push(frameCanvas.toDataURL('image/png'));
        updatePreview();
      }
      isDragging = false;
      drawCanvas();
    });

    canvas.addEventListener('wheel', (e) => {
      if (mode !== 'manual' || !spriteImage) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoom = Math.max(0.5, Math.min(3, zoom + delta));
      document.getElementById('zoomSlider').value = zoom;
      drawCanvas();
    });

    function undoLastSelection() {
      if (mode !== 'manual' || manualSelections.length === 0) return;
      manualSelections.pop();
      frames.pop();
      updatePreview();
      drawCanvas();
    }

    function updatePreview() {
      previewSection.innerHTML = '';
      frames.forEach((frameData, index) => {
        const frameImg = document.createElement('img');
        frameImg.src = frameData;
        frameImg.title = `Frame ${index + 1}`;
        frameImg.draggable = true;
        frameImg.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', index);
          frameImg.classList.add('dragging');
        });
        frameImg.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        frameImg.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          if (fromIndex !== toIndex) {
            const [movedFrame] = frames.splice(fromIndex, 1);
            frames.splice(toIndex, 0, movedFrame);
            if (mode === 'manual') {
              const [movedSelection] = manualSelections.splice(fromIndex, 1);
              manualSelections.splice(toIndex, 0, movedSelection);
            } else {
              const [movedSelection] = autoSelections.splice(fromIndex, 1);
              autoSelections.splice(toIndex, 0, movedSelection);
            }
            updatePreview();
            drawCanvas();
          }
        });
        frameImg.addEventListener('dragend', () => {
          frameImg.classList.remove('dragging');
        });
        frameImg.addEventListener('click', () => {
          frames.splice(index, 1);
          if (mode === 'manual') manualSelections.splice(index, 1);
          else autoSelections.splice(index, 1);
          updatePreview();
          drawCanvas();
        });
        previewSection.appendChild(frameImg);
      });
      status.textContent = frames.length === 0 ? status.textContent : `Frames: ${frames.length}`;
    }

    function exportToBigGifs() {
      alert('Export to BIG GIFS LAB functionality coming soon!');
    }
  </script>
</body>
</html>